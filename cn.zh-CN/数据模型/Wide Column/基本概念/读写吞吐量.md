# 读写吞吐量 {#concept_e5y_nmj_bfb .concept}

读/写吞吐量的单位为读服务能力单元和写服务能力单元，简称 CU （Capacity Unit），是数据读写操作的最小计费单位。

-   1 单位读能力表示从数据表中读一条 4 KB 数据。

-   1 单位写能力表示向数据表写一条 4 KB 数据。

-   操作数据大小不足 4 KB 的部分向上取整，如写入 7.6 KB 数据消耗 2 单位写能力，读出 0.1 KB 数据消耗 1 单位读能力。


应用程序通过 API 进行表格存储读写操作时，会消耗对应的写服务能力单元和读服务能力单元

## 预留读/写吞吐量 {#section_phr_gcg_cfb .section}

预留读/写吞吐量是表的一个属性。应用程序在创建表的时候，可以为该表指定预留读/写吞吐量。预留读写吞吐量的配置不影响该数据表的访问性能和服务能力。

设置预留吞吐量之后，应用程序每秒不超过预留吞吐量的访问将会按照预留吞吐量的单价进行计费。

例如，假设应用程序从表中每秒读取 80 条记录，每条记录的大小均为 3 KB，在这种情况下，每秒将消耗80个读吞吐量。

将预留读吞吐量设置为80 ，一个小时的读费用为 80 \* 预留读单价，能够处理的读操作为 80 \* 3600 = 288000 次。

**说明：** 

-   预留读/写吞吐量可以设置为 0。
-   当预留读/写吞吐量大于 0 时，表格存储根据该配置为表分配和预留相应的资源，从而获得更低的资源使用成本。
-   当预留读/写吞吐量大于 0 时，即使没有读写请求也会进行计费，所以表格存储限制用户能够自行设置的单表预留读写吞吐量最大为 5000 （读和写分别不超过 5000）。如果用户有单表预留读写吞吐量需要超出 5000 的需求，可以[提交工单](https://workorder-intl.console.aliyun.com/#/ticket/createIndex)提高预留读写吞吐量。
-   不存在的表将被视作预留读和预留写吞吐量均为 0，访问不存在的表将根据操作类型消耗 1 个按量读 CU 或者 1 个按量写 CU。

应用程序可以通过 UpdateTable 操作动态修改表的预留读/写吞吐量配置。

## 按量读/写吞吐量 {#section_hvl_gdg_cfb .section}

按量读/写吞吐量是数据表在每一秒钟实际消耗的读/写吞吐量中超出预留读/写吞吐量的部分，统计周期为 1 秒。

假如数据表设置的预留读吞吐量为 100，连续3秒的访问情况如下：

-   T0：读操作实际消耗 120 读吞吐量，则这 1 秒内预留吞吐量为100，消耗的按量读吞吐量为 20。
-   T1：读操作实际消耗 95 读吞吐量，则这 1 秒内预留吞吐量为100，消耗的按量读吞吐量为 0。
-   T2：读操作实际消耗 110 读吞吐量，则这 1 秒内预留吞吐量为100，消耗的按量读吞吐量为 10。

T0 至 T2 时刻的消耗的读吞吐量为：100 预留读吞吐量以及 30 按量读吞吐量。

**说明：** 每个小时内，表格存储对预留吞吐量取平均值，对按量吞吐量取累加值来作为用户实际消耗的吞吐量。

由于按量读/写吞吐量的模式无法预估需要为数据表预留的计算资源，表格存储需要提供足够的服务能力以应对突发的访问高峰，所以按量吞吐量的单价高于预留吞吐量的单价。合理设置数据表的预留吞吐量能够有效地降低使用成本。

**说明：** 由于按量读/写吞吐量无法准确估计需要预留的资源，在某些极端访问情况下，若单个分片键每秒钟的访问需要消耗 10000 CU，表格存储可能会返回 OTSCapacityUnitExhausted 错误给应用程序。此时，应用程序需要使用退避重试等策略来减少访问该表的频率。

更多信息请参考[Table Store 表](../../../../intl.zh-CN/产品功能/表格存储的表.md#)和[计费方式](../../../../intl.zh-CN/产品定价/计量项和计费说明.md#)。

