# 二级索引计量计费

二级索引包括全局二级索引和本地二级索引。使用二级索引功能将产生额外的数据存储量。当向数据表写入数据时，在建立索引的过程中将产生一定的读写CU。本文介绍二级索引费用组成及计费方式。

**说明：** CU（Capacity Unit）指读服务能力单元和写服务能力单元，是数据读写操作的最小计费单位。每秒1次4 KB单行读操作为1个预留读CU。

使用二级索引功能后，由于索引表的存在将产生额外的数据存储量。当向数据表中写入数据时，在建立索引的过程中将产生一定的读写CU。

索引表相关的计量包括三部分：索引表构建时的读写CU计量、索引表数据存储量计量、索引表读取数据计量。

|计费项|说明|
|---|--|
|数据存储|数据表以及索引表的数据存储费用。|
|构建索引表的读CU|为了支持索引行的计算（旧行删除、新行写入、原始行更新）而进行的必要读操作所产生的CU。|
|构建索引表的写CU|向索引表中写入索引行所产生的CU。|
|正常读CU|通过读接口对数据表或者索引表进行读取产生的CU。|
|正常写CU|通过写接口对数据表进行写入所产生的CU。|

索引的存储，计算及读取的规则为：

-   存储及读取计算规则都与数据表相同。更多信息，请参见[表格存储计量计费](/cn.zh-CN/产品定价/计费概述.md)。
-   索引表构建时的计量：
    -   只有产生了有效的索引行才会产生写CU。
    -   只要可能产生旧索引行的删除、旧索引行的更新、新索引行的写入，均会产生与索引列大小之和相当的读CU。

## 索引表构建时的读CU计量

数据表创建二级索引时，会产生一定量的读CU，具体规则如下：

-   当通过PUT操作写入一行新的数据，并且此行数据以前不存在时（非覆盖写场景）：
    -   如果数据表的非主键列上建有索引，但是此行数据不包含索引列（即此行不会生成索引行），则只产生一个读CU。
    -   如果此行数据所在的列建有索引，并且可以根据此行数据创建有效的索引（即此行会生成索引行），则产生一个读CU。
-   当通过PUT操作写入一行新的数据，并且此行数据以前存在时（覆盖写场景）：
    -   如果数据表的非主键列上建有索引，但此行数据旧值的非主键列不包含索引列，则只产生一个读CU。
    -   如果此行数据旧值所在的列建有索引，产生的读CU如下：

        该行旧值中，除主键外所有与索引表主键相关列的大小之和，按4 KB向上取整。如果为0，按1 CU计算。

-   当通过UPDATE操作更新一行数据时，并且此行数据以前不存在（非更新场景）：
    -   如果此行数据不涉及任何与索引表相关的列，则不产生读CU。
    -   如果此行数据涉及与索引表相关的列，则产生一个读CU。
-   当通过UPDATE操作更新一行数据时，并且此行数据以前存在（更新场景）：
    -   如果此次更新涉及到的所有属性列与任何索引表都无关，则不产生读CU。
    -   如果此次更新涉及到的所有属性列中存在部分列作为索引表的主键或者属性列，产生的读CU如下：

        该行旧值中，除主键外，所有与索引表主键相关列的大小之和，按4 KB向上取整。如果为0，则按1 CU计算。

-   当通过DELETE操作删除数据表中一行数据时，产生的读CU如下：

    该行除主键外，所有与索引表主键相关列的大小之和按4 KB向上取整。如果为0，则按1 CU计算。

-   对于主键自增的数据表，新写入数据时不产生读CU。修改一行通过主键自增写入的数据时会产生读CU，计算规则请参见上述UPDATE更新操作 。

    **说明：** 通过主键列自增功能写入数据可以大大减少由于索引表而产生的读CU。

    对于非主键列自增的表，只要发生了与索引相关列的读取，即使未读到数据，仍会产生1个读CU。但对于主键列自增的表，新写入数据时不会发生索引相关列的读取，不产生读CU。


## 索引表构建时的写CU计量

在为写入主表中的数据创建索引时，会产生一定量的写CU。计量原则如下：

-   如果对数据表写入一行数据后，索引表的数据没有发生变化，则不产生写CU。
-   如果对数据表写入一行数据后，索引表增加了一行，则产生与增加的索引行大小相当的写CU。
-   如果对数据表写入一行数据后，索引表删除了一行，则产生与删除的索引行大小相当的写CU。
-   如果对数据表写入一行数据后，索引表更新了一行，则产生与更新的索引行属性列大小相当的写CU。
-   如果对数据表写入一行数据后，索引表删除了一行并又增加了一行，则产生与删除的索引行和增加的索引行之和大小相当的写CU。

具体细则如下：

-   当通过PUT操作写入一行新的数据，并且此行数据以前不存在（非覆盖写场景）：
    -   如果数据表的非主键列上建有索引，但是此行数据不涉及索引列（即此行不会生成索引行），则不产生写CU。
    -   如果此行数据所在的列建有索引，并且可以根据此行数据创建有效的索引（即此行会生成索引行），则每张索引表产生的写CU如下：

        如果生成了有效的索引行，索引表写CU的个数计量与数据表相同，按4 KB向上取整，否则不产生写CU。

-   当通过PUT操作写入一行新的数据，并且此行数据以前存在时（覆盖写场景）：
    -   如果数据表的非主键列上建有索引，但是此行数据旧值的非主键列不涉及索引列，则不产生写CU。
    -   如果此行数据旧值的主键或者属性列上建有索引，则每张索引表产生的写CU如下：

        对于该次PUT操作影响到的所有索引（稀疏索引可能不受影响），均计算相应的写CU。

-   当通过UPDATE操作更新一行数据，并且此行数据以前不存在（非更新场景）：
    -   如果此行数据不涉及任何索引表相关的列，则不产生写CU。
    -   如果此行数据涉及索引表相关的列，则每张索引表产生的写CU如下：
        -   如果该行能够生成有效的索引行，则以索引行的大小除以4 KB向上取整进行写CU计量。
        -   如果该行不能够生成有效的索引行，则不会产生索引表的写CU。
-   当通过UPDATE操作更新一行数据，并且此行数据以前存在（更新场景）：
    -   如果此次更新涉及到的所有属性列，都与任何索引表无关，则不产生写CU。
    -   如果此次更新涉及到的所有属性列中，部分列作为索引表的主键或者属性列，则每张索引表产生的写CU如下：

        -   如果该行的旧值生成了有效的索引行，则按旧的索引行的主键大小，产生索引行的删除CU。
        -   如果该行的新值生成新的有效的索引行，则按新的索引行的主键大小，产生新的索引行的写入CU。
        -   如果该行的新值没有生成新的有效的索引行，只是更新了旧的索引行的属性列，则只产生旧的索引行的更新CU。
        计算规则均按索引行的大小除以4 KB向上取整。

-   当通过DELETE操作删除主表中一行数据时，产生的写CU如下：

    对每张索引表，如果该行有相应的索引行，则该行中所有与索引表主键相关的列的大小之和，按4 KB向上取整，否则写 CU为0。

-   对于主键列自增的表，新写入数据时会产生索引表的写CU，写CU计算规则与上述的通过PUT操作写入一行新数据计算规则相同。修改一行通过主键列自增写入的数据时，会产生写CU，计算规则与上述的通过UPDATE操作更新一行数据计算规则相同。

## 索引表数据存储量计量

索引表的数据存储量与数据表无区别。索引表的数据量是索引表中所有行的数据量之和，所有行的数据量是所有单行数据的主键和属性列数据量之和。更多信息，请参见[数据存储量](/cn.zh-CN/产品定价/数据存储量.md)。

## 索引表读取计量

通过控制台、SDK或者其它途径（例如DLA）进行索引表的读取时，读CU计量规则与数据表相同。

## 计算举例

如下以包含两张索引表的数据表为例介绍在不同写入模式下CU的计算。

假设有数据表Table，其中有两列主键PK0和PK1 ，另外有三列预定义列Col0、Col1、Col2。数据表上建有两张索引表Index0和Index1。其中Index0的主键为Col0、PK0、PK1，有一属性列Col2；Index1的主键为Col1、Col0、PK0、PK1，没有属性列。通过UPDATE接口更新PK0、PK1。

-   如果该行以前不存在
    -   更新Col3列：不产生读写CU
    -   更新Col1列：产生1个读CU，不产生写CU
    -   更新 Col0、 Col1 两列：
        -   产生1个读CU
        -   对于Index0，产生与Col0、PK0、PK1大小之和相当的写CU。对于Index1，产生Col0、Col1、PK0、PK1大小之和相当的写CU。
-   如果该行以前存在
    -   更新Col3列：不产生读写CU
    -   更新Col2列：
        -   产生旧的Col0列大小相当的读CU，如果Col0列以前不存在，则按1 CU计算。
        -   对于Index0，如果Col0列以前不存在，则不产生写CU；如果存在，则产生Col0、PK0、PK1、Col2大小之和相当的写CU。对于Index1，则不产生写CU。
    -   更新Col1列：
        -   产生旧的Col0列以及Col1列大小之和相当的读CU。如果为0，则按1 CU计算。
        -   对于Index0，不产生写CU。对于Index1，会产生旧的Col0 、新的Col1列、PK0、PK1大小之和相当的写CU（写入新的索引行）。如果旧的Col0列不存在，则不产生写CU（没有生成新的索引行）。另外如果旧的Col0列以及旧的Col1列都存在，则会产生旧的Col0、旧的Col1、PK0、PK1大小之和相当的写CU（删除旧的索引行）。

