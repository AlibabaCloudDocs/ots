# 表格存储的表 {#concept_27297_zh .concept}

创建表格存储的表时，需要指定表名、主键和预留读/写吞吐量。在传统数据库中，表具有预定义的结构信息，比如表的名称、主键、列名和类型，表中的所有行都具有相同的列集合。表格存储是 NoSQL 数据库，除了主键需要格式外，没有其他的格式信息。本章将介绍表的概念和使用。

## 表名 {#section_wml_skg_cfb .section}

表格存储的表的名称必须符合以下规范：

-   由英文字符（a-z）或（A-Z）、数字（0-9）和下划线（\_）组成。

-   首字母必须为英文字母（a-z）、（A-Z）或下划线（\_）。

-   大小写敏感。

-   长度在 1~255 字符之间。

-   同一个实例下不能有同名的表，但不同实例内的表名称可以相同。


## 主键 { .section}

创建表格存储的表时必须指定表的主键。主键包含 1~4 个主键列，每个主键列都有名字和类型。表格存储对主键列的名字和类型都有限制，详细信息请参考[主键和属性](../../../../intl.zh-CN/数据模型/Wide Column/基本概念/主键和属性.md#)。

表格存储根据表的主键索引数据，表中的行按照它们的主键进行升序排序。

## 配置预留读/写吞吐量 { .section}

为确保应用程序获得稳定、低延时的服务，应用程序可以在创建表的时候指定预留读/写吞吐量。如果预留读/写吞吐量不为 0，表格存储根据预留读/写吞吐量来为表分配相应的资源，满足应用程序的预留吞吐量需求，同时根据配置的预留读/写吞吐量收取相应费用。应用程序可以根据自身的业务需求动态上调和下调表的预留读/写吞吐量。预留读/写吞吐量通过读服务能力单元和写服务能力单元这两个数值来设置。

**说明：** 容量型实例下的表不支持预留读/写吞吐量。

通过 UpdateTable 操作可以更新表的预留读/写吞吐量。预留读/写吞吐量的更新有如下规则：

-   一张表上的两次更新的间隔必须大于 2 分钟。例如，12:43 AM 更新了某个表的预留读/写吞吐量，那么只有在 12:45 AM 之后才能再次更新该表的预留读/写吞吐量。更新间隔必须大于 2 分钟的限制是针对表的，在 12:43 AM ~ 12:45 AM 之间，用户可以更新其他表的预留读/写吞吐量。

-   每个自然日内（UTC 时间 00:00:00 到第二天的 00:00:00，北京时间早上 8 点到第二天早上 8 点），上调或者下调预留读/写吞吐量的总次数不做限制，但是两次调整之间的时间间隔必须大于 2 分钟。调整预留读/写吞吐量的定义是，只要读服务能力单元或写服务能力单元配置其中一项进行了更新，则此次操作被视为对表进行了更新。

-   预留读/写吞吐量调整完毕后 1 分钟内生效。


对于访问消耗的读/写吞吐量中，超出预留读/写吞吐量的部分，会计入按量读/写吞吐量，并根据按量读/写吞吐量单价进行计费。

由于预留读/写吞吐量在单价上低于按量读/写吞吐量，配置合适的预留读/写吞吐量可以进一步降低成本。例如，在用户刚建表之后如果需要导入大量数据，可以设置较大的预留写吞吐量，能够以较低的写成本将数据导入进来，当数据导入完毕后，再将预留读/写吞吐量下调。

## 分区键下的数据量限制 { .section}

表格存储按照分区键的范围对表的数据进行分区，拥有相同分区键的行会被划分到同一个分区。为了防止分区过大无法切分，建议单个分区键值下的所有行数据大小之和不要超过 10 GB。

## 建表后加载时间 {#section_uqt_zkg_cfb .section}

表格存储的表在被创建之后需要 1 分钟进行加载，在此期间对该表的读/写数据操作均会失败。应用程序应该等待表加载完毕后再进行数据操作。

## 最佳实践 {#section_vqt_zkg_cfb .section}

 [表格存储表的最佳实践](../../../../intl.zh-CN/最佳实践/表操作篇.md#) 

## 使用表格存储的 SDK 进行表操作 {#section_vmz_1lg_cfb .section}

[JAVA-SDK -- 表操作](../../../../intl.zh-CN/SDK 参考/Java SDK/表操作/概述.md) 

 [Python-SDK -- 表操作](../../../../intl.zh-CN/SDK 参考/Python SDK/简介.md#) 

