# 计量计费 {#concept_nnw_b1f_zgb .concept}

本文主要介绍索引表构建时，读 CU、写 CU 的计量标准 。

使用二级索引功能后，由于索引表的存在，将产生额外的数据存储量。当向主表中写入数据时，在建立索引的过程中，将产生一定的读写 CU。

索引表相关的计量分三部分：索引表构建时的读写 CU 计量，索引表数据存储量计量，索引表读取数据计量。

|计费项|说明|
|---|--|
|数据存储|主表以及索引表的数据存储费用。|
|索引构建读 CU|为了支持索引行的计算（旧行删除，新行写入，原始行更新）而进行的必要读操作所产生的 CU。|
|索引构建写 CU|为了向索引表中写入索引行所产生的 CU。|
|正常读 CU|通过读接口对主表或者索引进行读取产生的 CU。|
|正常写 CU|通过写接口对主表进行写入产生的 CU。|

索引的存储，计算及读取的规则为：

1.  存储及读取计算规则都与主表相同，详情请参见[表格存储计量计费](../../../../../cn.zh-CN/产品定价/计量项和计费说明.md#)。
2.  索引表构建时的计量：
    1.  只有产生了有效的索引行才会产生写 CU。
    2.  只要可能产生旧索引行的删除、旧索引行的更新、新索引行的写入，均会产生索引列大小之和相当的读 CU。

## 索引表构建时的读 CU 计量 {#section_j2w_xcf_zgb .section}

在为用户写入主表中的数据计算索引时，会产生一定量的读 CU，具体规则如下：

1.  当通过 Put 操作写入一行新的数据，并且此行数据以前不存在时（非覆盖写场景）：
    1.  如果此表的非主键列上建有索引，但是此行数据不涉及索引列（即此行不会生成索引行），则只产生一个读 CU。
    2.  如果此行数据的主键或者属性列上建有索引，并且可以根据此行数据创建有效的索引（即此行会生成索引行），则产生一个读 CU。
2.  当通过 Put 操作写入一行新的数据，并且此行数据以前存在时（覆盖写场景）：
    1.  如果此张表的非主键列上建有索引，但此行数据旧值的非主键列不涉及索引列，则只产生一个读 CU。
    2.  如果此行数据旧值的主键或者属性列上有索引，则产生的读 CU 为：

        该行旧值除主键外，所有与索引表主键相关列的大小之和按 4 KB 向上取整，如果为 0 按 1CU 计算。

3.  当通过 Update 操作更新一行数据时，并且此行数据以前不存在（非更新场景）：
    1.  如果此行数据不涉及任何与索引表相关的列，则不产生读 CU。
    2.  如果此行数据涉及与索引表相关的列，则产生一个读 CU。
4.  当通过 Update 操作更新一行数据时，并且此行数据以前存在（更新场景）：
    1.  如果此次更新涉及到的所有属性列与任何索引表都无关，则不产生读 CU。
    2.  如果此次更新涉及到的所有属性列中，部分列作为索引表的主键或者属性列，则产生读 CU。该行旧值除 PK 外，所有与索引表相关列的大小之和按 4KB 向上取整，如果为 0 则按 1CU 计算。
5.  当通过 Delete 操作删除主表中一行数据时，产生的读 CU 为：

    该行除主键外，所有与索引表主键相关列的大小之和按 4 KB 向上取整，如果为 0 则按 1CU 计算。

6.  对于 PK 自增列的表，新写入数据时不产生读 CU。修改一行通过 PK 自增写入数据时会产生读 CU，计算规则请参见上述 Update 更新操作 。

    **说明：** 我们鼓励通过 PK 自增功能写入数据，这样可以大大减少由于索引表而产生的读 CU。

    对于非 PK 自增列的表，只要发生了与索引相关列的读取，即使没有读到数据，仍会产生1个读CU。但是对于 PK 自增列的表，新写入数据时不会发生索引相关列的读取，不产生读 CU。


## 索引表构建时的写 CU 计量 {#section_cm5_ycf_zgb .section}

在为用户写入主表中的数据计算索引时，会产生一定量的写 CU。计量原则如下：

1.  如果对主表写入一行数据后，索引表的数据没有发生变化，则不产生写 CU。
2.  如果对主表写入一行数据后，索引表增加了一行，则产生与增加的索引行大小相当的写 CU。
3.  如果对主表写入一行数据后，索引表删除了一行，则产生与删除的索引行大小相当的写 CU。
4.  如果对主表写入一行数据后，索引表更新了一行，则产生与更新的索引行属性列大小相当的写 CU。
5.  如果对主表写入一行数据后，索引表删除了一行并又增加了一行，则产生与删除的索引行和增加的索引行大小相当的写 CU。

具体的细则如下：

1.  当通过 Put 操作写入一行新的数据，并且此行数据以前不存在（非覆盖写场景）：
    1.  如果此张表的非主键列上建有索引，但是此行数据不涉及索引列（即此行不会生成索引行），则不会产生写 CU。
    2.  如果此行数据的主键或者属性列上建有索引，并且可以根据此行数据创建有效的索引（即此行会生成索引行），则每张索引表产生的写CU为：如果生成了有效的索引行，索引表写 CU 的个数计量与主表相同，以 4KB 为单位向上对齐，否则不产生写 CU。
2.  当通过 Put 操作写入一行新的数据，并且此行数据以前存在时（覆盖写场景）：
    1.  如果此张表的非主键列上建有索引，但是此行数据旧值的非主键列不涉及索引列，则不产生写 CU。
    2.  如果此行数据旧值的主键或者属性列上建有索引，则每张索引表产生的写 CU 为：对于该次 Put 操作影响到的所有索引（稀疏索引可能不被影响到），均计算相应的写 CU。
3.  当通过 Update 操作更新一行数据，并且此行数据以前不存在（非更新场景）：
    1.  如果此行数据不涉及任何索引表相关的列，则不产生写 CU。
    2.  如果此行数据涉及索引表相关的列，则每张索引表产生的写 CU 为：
        -   如果该行能够生成有效的索引行，则以索引行的大小，按 4KB 向上取整进行写 CU 计量。
        -   如果该行不能够生成有效的索引行，则不会产生索引表的写 CU。
4.  当通过 Update 操作更新一行数据，并且此行数据以前存在（更新场景）：
    1.  如果此次更新涉及到的所有属性列，都与任何索引表无关，则不产生写 CU。
    2.  如果此次更新所涉及到的所有属性列中，部分列作为索引表的主键或者属性列，则每张索引表产生的写 CU 为：

        -   如果该行的旧值生成了有效的索引行，则按旧的索引行的主键大小，产生索引行的删除 CU。
        -   如果该行的新值生成新的有效的索引行，则按新的索引行的主键大小，产生新的索引行的写入 CU。
        -   如果该行的新值没有生成新的有效的索引行，只是更新了旧的索引行的属性列，则只产生旧的索引行的更新 CU。
        计算规则均按索引行的大小，按 4KB 向上取整。

5.  当通过Delete操作删除主表中一行数据时，产生的写 CU 为：

    对每张索引表，如果该行有相应的索引行，则该行中所有与索引表主键相关的列的大小之和，按 4KB 向上取整，否则写 CU 为 0。

6.  对于 PK 自增列的表，新写入数据时会产生索引表的写 CU，写 CU 计算规则与上述的通过 Put 操作写入一行新数据计算规则相同。修改一行通过 PK 自增写入的数据时，会产生写 CU，计算规则与规则4通过Update 操作更新一行数据计算规则相同。

## 索引表数据存储量计量 {#section_yy2_1df_zgb .section}

对于索引表，其数据存储量与正常主表没有区别。索引表的数据量是索引表中所有行的数据量之和，所有行的数据量是所有单行数据的主键列和属性列数据量之和，详情请参见[数据存储量](../../../../../cn.zh-CN/产品定价/数据存储量.md#)。

## 索引表读取计量 {#section_ol5_1df_zgb .section}

用户通过控制台、SDK或者其它途径（如 DLA）进行索引表的读取时，读 CU 计量规则与主表相同，没有区别。

## 计算举例 {#section_nml_cdf_zgb .section}

我们以包含两张索引表的主表为例，说明在不同写入模式下 CU 的计算。

假设有主表 Table，其中有两列主键 PK0 和 PK1 ，另外有三列预定义列 Col0、Col1、Col2。主表上建有两张索引表 Index0 和 Index1。其中 Index0 的主键为 Col0、PK0、PK1，有一列属性列 Col2；Index1 的主键为 Col1、Col0、PK0、PK1，没有属性列。用户通过Update 接口更新 PK0、PK1 。

-   该行以前不存在
    1.  更新 Col3 列：不产生读写 CU
    2.  更新 Col1 列：
        1.  产生1个读 CU
        2.  不产生写 CU
    3.  更新 Col0、 Col1 两列：
        1.  产生1个读 CU
        2.  对于 Index0，产生与 Col0、PK0、PK1 大小之和相当的写 CU。对于 Index1，产生 Col0、 Col1、PK0、PK1 大小之和相当的写 CU。
-   该行以前存在
    1.  更新 Col3 列：不产生读写 CU
    2.  更新 Col2 列：
        1.  产生旧的 Col0 列大小相当的读 CU，如果 Col0 列以前不存在，则按 1CU 计算
        2.  对于 Index0，如果 Col0 列以前不存在，则不产生写 CU；如果存在，产生Col0、PK0、PK1、Col2 大小之和相当的写 CU。对于 Index1，则不产生写 CU。
    3.  更新 Col1 列：
        1.  产生旧的 Col0 列以及 Col1 列大小之和相当的读 CU，如果为 0 则按 1CU 计算。
        2.  对于 Index0，不产生写 CU。对于 Index1，会产生旧的 Col0 列、新的 Col1 列、PK0、PK1大小之和相当的写 CU（写入新的索引行）。如果旧的 Col0 列不存在，则不产生写 CU（没有生成新的索引行）。另外，如果旧的 Col0 列以及旧的 Col1 列都存在，则会产生旧的 Col0、旧的Col1、PK0、PK1大小之和相当的写 CU（删除旧的索引行）

