# Single-row operations

Tablestore provides the following single-row operations: PutRow, GetRow, UpdateRow, and DeleteRow.

## Prerequisites

-   The OTSClient instance is initialized. For more information, see [Initialization](/intl.en-US/SDK Reference/Java SDK/Initialization.md).
-   A data table is created and data is written to the table.

## PutRow

You can call this operation to insert a row of data. If the row you want to insert exists, the PutRow operation deletes all columns and versions from the existing row and then inserts the new row.

-   Parameters

    |Parameter|Description|
    |---------|-----------|
    |tableName|The name of the table.|
    |primaryKey|The primary key of the row.**Note:**

    -   The configured number and types of primary key columns must be consistent with the number and types of primary key columns of the table.
    -   For an auto-increment primary key column, you need only to set the value of the auto-increment primary key column to a placeholder. For more information, see [Configure an auto-increment primary key column](/intl.en-US/SDK Reference/Java SDK/Table operations/Configure an auto-increment primary key column.md). |
    |condition|You can use conditional update to set a row existence condition or columns-based conditions for the row. For more information, see [Configure conditional update](/intl.en-US/SDK Reference/Java SDK/Table operations/Configure conditional update.md).**Note:**

    -   RowExistenceExpectation.IGNORE indicates that new data is inserted into a row no matter whether the specified row exists. If the specified row exists, the existing data is overwritten.
    -   RowExistenceExpectation.EXPECT\_EXIST indicates that new data is inserted only when the specified row exists. The existing data is overwritten.
    -   RowExistenceExpectation.EXPECT\_NOT\_EXIST indicates that data is inserted only when the specified row does not exist. |
    |column|The attribute column of the row.    -   An attribute column is specified by parameters in the following sequence: the attribute column name, attribute column value \(ColumnValue\), attribute column value type \(ColumnType, which is optional\), and timestamp \(optional\).
    -   You can set ColumnType to ColumnType.INTEGER, ColumnType.STRING, ColumnType.BINARY, ColumnType.BOOLEAN, or ColumnType.DOUBLE, which separately indicates INTEGER, STRING \(a UTF-8 encoded string\), BINARY, BOOLEAN, or DOUBLE. If you want to set the column value type to BINARY, you must set ColumnType to ColumnType.BINARY. If you want to use other types of column values, the setting of ColumnType is optional.
    -   A timestamp is the data version number. For more information, see [Max versions and TTL](/intl.en-US/Function Introduction/Wide Column model/Max versions and TTL.md).

You can customize a data version number or use the data version number generated by Tablestore. If you do not specify this parameter, the data version number generated by the system is used.

        -   The version number is calculated based on the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.
        -   If you choose to specify the version number, ensure that the version number is a 64-bit timestamp accurate to the millisecond within the valid version range. |

-   Example 1

    The following code provides an example on how to write a row that contains 10 attribute columns and write one version of data for each column. The version number \(timestamp\) is generated by Tablestore.

    ```
    private static void putRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
        // Specify the name of the table.
        RowPutChange rowPutChange = new RowPutChange(TABLE_NAME, primaryKey);
    
        // Add attribute columns.
        for (int i = 0; i < 10; i++) {
            rowPutChange.addColumn(new Column("Col" + i, ColumnValue.fromLong(i)));
        }
    
        client.putRow(new PutRowRequest(rowPutChange));
    }
                        
    ```

-   Example 2

    The following code provides an example on how to write a row that contains 10 attribute columns and write three versions of data for each column. In this example, a custom version number \(timestamp\) is used.

    ```
    private static void putRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
        // Specify the name of the table.
        RowPutChange rowPutChange = new RowPutChange(TABLE_NAME, primaryKey);
    
        // Add attribute columns.
        long ts = System.currentTimeMillis();
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 3; j++) {
                rowPutChange.addColumn(new Column("Col" + i, ColumnValue.fromLong(j), ts + j));
            }
        }
    
        client.putRow(new PutRowRequest(rowPutChange));
    }
                        
    ```

-   Example 3

    The following code provides an example on how to write a row that contains 10 attribute columns and write three versions of data for each column. In this example, a condition that expects the row not to exist is set and a custom version number \(timestamp\) is used.

    ```
    private static void putRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
        // Specify the name of the table.
        RowPutChange rowPutChange = new RowPutChange(TABLE_NAME, primaryKey);
    
        // Set a condition that expects the specified row not to exist.
        rowPutChange.setCondition(new Condition(RowExistenceExpectation.EXPECT_NOT_EXIST));
    
        // Add attribute columns.
        long ts = System.currentTimeMillis();
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 3; j++) {
                rowPutChange.addColumn(new Column("Col" + i, ColumnValue.fromLong(j), ts + j));
            }
        }
    
        client.putRow(new PutRowRequest(rowPutChange));
    }
                        
    ```

-   Example 4

    The following code provides an example on how to write a row that contains 10 attribute columns and write three versions of data for each column. In this example, a condition that expects the row to exist and the Col0 value of the row to be greater than 100 is set and a custom version number \(timestamp\) is used.

    ```
    private static void putRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
        // Specify the name of the table.
        RowPutChange rowPutChange = new RowPutChange(TABLE_NAME, primaryKey);
    
        // Set a condition that expects the row to exist and the Col0 value of the row to be greater than 100.
        Condition condition = new Condition(RowExistenceExpectation.EXPECT_EXIST);
        condition.setColumnCondition(new SingleColumnValueCondition("Col0",
                SingleColumnValueCondition.CompareOperator.GREATER_THAN, ColumnValue.fromLong(100)));
        rowPutChange.setCondition(condition);
    
        // Add attribute columns.
        long ts = System.currentTimeMillis();
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 3; j++) {
                rowPutChange.addColumn(new Column("Col" + i, ColumnValue.fromLong(j), ts + j));
            }
        }
    
        client.putRow(new PutRowRequest(rowPutChange));
    }
                        
    ```


## GetRow

You can call this operation to read a row of data.

The following results for the read request may be returned:

-   If the row exists, the primary key columns and attribute columns of the row are returned.
-   If the row does not exist, no row is returned and no error is reported.

-   Parameters

    |Parameter|Description|
    |---------|-----------|
    |tableName|The name of the table.|
    |primaryKey|The primary key of the row.**Note:** The configured number and types of primary key columns must be consistent with the number and types of primary key columns of the table. |
    |columnsToGet|The names of the columns to return. You can specify the names of the primary key columns and the names of attribute columns. If you do not specify this parameter, all data in the row is returned.

**Note:**

    -   By default, when you query a row of data, Tablestore returns all columns of the row. You can configure the columnsToGet parameter to return data of specified columns. For example, if you include col0 and col1 in columnsToGet, only the values of col0 and col1 are returned.
    -   If you use columnsToGet and filter together, Tablestore first queries the columns specified by columnsToGet, and then returns rows that meet the filter conditions. |
    |maxVersions|The maximum number of versions that can be read.**Note:** You must set at least one of the following parameters: maxVersions and timeRange.

    -   If you specify only maxVersions, data of up to the specified number of versions is returned from the latest to the earliest.
    -   If you specify only timeRange, data whose version number is within the specified range or a specified version of data is returned.
    -   If you specify both maxVersions and timeRange, data of up to the specified number of versions within the time range is returned from the latest to the earliest. |
    |timeRange|Specifies a range of versions to read or a version of data to read. For more information, see [TimeRange](/intl.en-US/API Reference/Data Types/TimeRange.md).**Note:** You must set at least one of the following parameters: maxVersions and timeRange.

    -   If you specify only maxVersions, data of up to the specified number of versions is returned from the latest to the earliest.
    -   If you specify only timeRange, data whose version number is within the specified range or a specified version of data is returned.
    -   If you specify both maxVersions and timeRange, data of up to the specified number of versions within the time range is returned from the latest to the earliest.
    -   To query data within a range, you must set start and end. start indicates the start timestamp. end indicates the end timestamp. The specified range includes the start timestamp and excludes the end timestamp.
    -   To query data of a specific version number, you must set the timestamp. timestamp indicates a specified version number.
You need only to set one of following parameters: timestamp and \[start, end\).

The value of timestamp ranges from 0 to Long.MAX\_VALUE. Unit: milliseconds. |
    |filter|Specifies filter conditions to filter the queried results on the server side. Only rows that meet the specified filter conditions are returned. For more information, see [Configure filter](/intl.en-US/SDK Reference/Java SDK/Table operations/Configure filter.md).**Note:** If you use columnsToGet and filter together, the system first queries the columns specified by columnsToGet, and then returns rows that meet the filter conditions. |

-   Example 1

    The following code provides an example on how to read the latest versions of the specified columns from a row:

    ```
    private static void getRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
    
        // Specify the table name and primary key to read a row of data.
        SingleRowQueryCriteria criteria = new SingleRowQueryCriteria(TABLE_NAME, primaryKey);
        // Set MaxVersions to 1 to read the latest version of data.
        criteria.setMaxVersions(1);
        GetRowResponse getRowResponse = client.getRow(new GetRowRequest(criteria));
        Row row = getRowResponse.getRow();
    
        System.out.println("Read complete. Result:");
        System.out.println(row);
    
        // Specify the columns to read.
        criteria.addColumnsToGet("Col0");
        getRowResponse = client.getRow(new GetRowRequest(criteria));
        row = getRowResponse.getRow();
    
        System.out.println("Read complete. Result:");
        System.out.println(row);
    } 
    ```

-   Example 2

    The following code provides an example on how to set filter conditions to read a row of data:

    ```
    private static void getRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
    
        // Specify the table name and primary key to read a row of data.
        SingleRowQueryCriteria criteria = new SingleRowQueryCriteria(TABLE_NAME, primaryKey);
        // Set MaxVersions to 1 to read the latest version of data.
        criteria.setMaxVersions(1);
    
        // Set a filter to return the row when the value in Col0 is 0.
        SingleColumnValueFilter singleColumnValueFilter = new SingleColumnValueFilter("Col0",
                SingleColumnValueFilter.CompareOperator.EQUAL, ColumnValue.fromLong(0));
        // If the Col0 column does not exist, the row is not returned.
        singleColumnValueFilter.setPassIfMissing(false);
        criteria.setFilter(singleColumnValueFilter);
    
        GetRowResponse getRowResponse = client.getRow(new GetRowRequest(criteria));
        Row row = getRowResponse.getRow();
    
        System.out.println("Read complete. Result:");
        System.out.println(row);
    }
    ```


## UpdateRow

You can call this operation to update data of a specified row. You can add attribute columns to or delete attribute columns from a row, delete a specified version of data from an attribute column, or update the value of an existing attribute column. If the row does not exist, a new row is added.

**Note:** If the UpdateRow request only contains columns to delete, and the specified row does not exist, a new row is not added.

-   Parameters

    |Parameter|Description|
    |---------|-----------|
    |tableName|The name of the table.|
    |primaryKey|The primary key of the row.**Note:** The configured number and types of primary key columns must be consistent with the number and types of primary key columns of the table. |
    |condition|You can use conditional update to set a row existence condition or columns-based conditions for the row. For more information, see [Configure conditional update](/intl.en-US/SDK Reference/Java SDK/Table operations/Configure conditional update.md).|
    |column|The attribute column you want to update.    -   To add an attribute column or update the value of an existing attribute column, you must specify the name, value and type \(optional\) of the attribute column, and a timestamp \(optional\).

The timestamp is the version number of the data. It can be automatically generated or customized. If you do not specify this parameter, Tablestore automatically generates a timestamp. For more information, see [Max versions and TTL](/intl.en-US/Function Introduction/Wide Column model/Max versions and TTL.md).

        -   The version number is calculated based on the number of milliseconds that have elapsed since 00:00:00 UTC on January 1, 1970.
        -   If you choose to specify the version number, ensure that the version number is a 64-bit timestamp accurate to the millisecond within the valid version range.
    -   You need only to set the name of the attribute column and the timestamp to delete a specified version of data in an attribute column.

A timestamp is a 64-bit integer that indicates a specified version of data. Unit: milliseconds.

    -   You need only to set the name of the attribute column to delete an attribute column.

**Note:** A row exists even if all attribute columns in the row are deleted. To delete a row, use the DeleteRow operation. |

-   Example 1

    The following code provides an example of how to update columns, delete the specified version of a column, and delete a specified column of a row:

    ```
    private static void updateRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
        // Specify the name of the table.
        RowUpdateChange rowUpdateChange = new RowUpdateChange(TABLE_NAME, primaryKey);
    
        // Update columns.
        for (int i = 0; i < 10; i++) {
            rowUpdateChange.put(new Column("Col" + i, ColumnValue.fromLong(i)));
        }
    
        // Delete a specified version of a specified column.
        rowUpdateChange.deleteColumn("Col10", 1465373223000L);
    
        // Delete a specified column.
        rowUpdateChange.deleteColumns("Col11");
    
        client.updateRow(new UpdateRowRequest(rowUpdateChange));
    }                   
    ```

-   Example 2

    The following code provides an example on how to configure update conditions:

    ```
    private static void updateRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
        // Specify the name of the table.
        RowUpdateChange rowUpdateChange = new RowUpdateChange(TABLE_NAME, primaryKey);
    
        // Set a condition that expects the row to exist and the Col0 value of the row to be greater than 100.
        Condition condition = new Condition(RowExistenceExpectation.EXPECT_EXIST);
        condition.setColumnCondition(new SingleColumnValueCondition("Col0",
                SingleColumnValueCondition.CompareOperator.GREATER_THAN, ColumnValue.fromLong(100)));
        rowUpdateChange.setCondition(condition);
    
        // Update columns.
        for (int i = 0; i < 10; i++) {
            rowUpdateChange.put(new Column("Col" + i, ColumnValue.fromLong(i)));
        }
    
        // Delete a specified version of a specified column.
        rowUpdateChange.deleteColumn("Col10", 1465373223000L);
    
        // Delete a specified column.
        rowUpdateChange.deleteColumns("Col11");
    
        client.updateRow(new UpdateRowRequest(rowUpdateChange));
    }             
    ```


## DeleteRow

You can call this operation to delete a row of data. If the row to delete does not exist, no changes are made to the table.

-   Parameters

    |Parameter|Description|
    |---------|-----------|
    |tableName|The name of the table.|
    |primaryKey|The primary key of the row.**Note:** The configured number and types of primary key columns must be consistent with the number and types of primary key columns of the table. |
    |condition|You can use conditional update to set a row existence condition or columns-based conditions for the row. For more information, see [Configure conditional update](/intl.en-US/SDK Reference/Java SDK/Table operations/Configure conditional update.md).|

-   Example 1

    The following code provides an example on how to delete a row from a table:

    ```
    private static void deleteRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
        // Specify the name of the table.
        RowDeleteChange rowDeleteChange = new RowDeleteChange(TABLE_NAME, primaryKey);
    
        client.deleteRow(new DeleteRowRequest(rowDeleteChange));
    }                    
    ```

-   Example 2

    The following code provides an example on how to set deletion conditions:

    ```
    private static void deleteRow(SyncClient client, String pkValue) {
        // Construct the primary key.
        PrimaryKeyBuilder primaryKeyBuilder = PrimaryKeyBuilder.createPrimaryKeyBuilder();
        primaryKeyBuilder.addPrimaryKeyColumn(PRIMARY_KEY_NAME, PrimaryKeyValue.fromString(pkValue));
        PrimaryKey primaryKey = primaryKeyBuilder.build();
        // Specify the name of the table.
        RowDeleteChange rowDeleteChange = new RowDeleteChange(TABLE_NAME, primaryKey);
    
        // Set a condition that expects the row to exist and the Col0 value of the row to be greater than 100.
        Condition condition = new Condition(RowExistenceExpectation.EXPECT_EXIST);
        condition.setColumnCondition(new SingleColumnValueCondition("Col0",
                SingleColumnValueCondition.CompareOperator.GREATER_THAN, ColumnValue.fromLong(100)));
        rowDeleteChange.setCondition(condition);
    
        client.deleteRow(new DeleteRowRequest(rowDeleteChange));
    }                   
    ```


